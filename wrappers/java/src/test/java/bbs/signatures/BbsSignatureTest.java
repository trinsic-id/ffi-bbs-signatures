/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package bbs.signatures;

import org.junit.Test;

import java.util.Collections;
import java.util.Map;

import static org.junit.Assert.*;

public class BbsSignatureTest {

    public KeyPair keyPair;

    @Test
    public void canGetCorrectBls12381G1PublicKeySize() {
        int size = Bbs.getBls12381G1PublicKeySize();
        assertEquals(size, 48);
    }

    @Test
    public void canGetCorrectBls12381G2PublicKeySize() {
        int size = Bbs.getBls12381G2PublicKeySize();
        assertEquals(size, 96);
    }

    @Test
    public void canGetSecretKeySize() {
        int size = Bbs.getSecretKeySize();
        assertEquals(size, 32);
    }

    @Test
    public void canGetSignatureSize() {
        int size = Bbs.getSignatureSize();
        assertEquals(size, 112);
    }

    @Test
    public void canGetBlindSignatureSize() {
        int size = Bbs.getBlindSignatureSize();
        assertEquals(size, 112);
    }

    @Test
    public void canGenerateBls12381G1Key() {
        byte[] seed = new byte[0];
        KeyPair keyPair = null;

        try {
            keyPair = Bbs.generateBls12381G1Key(seed);
        } catch (Exception exception) {
            exception.printStackTrace();
        }

        assertNotNull(keyPair);
        assertEquals(keyPair.publicKey.length, Bbs.getBls12381G1PublicKeySize());
        assertEquals(keyPair.secretKey.length, Bbs.getSecretKeySize());
    }

    @Test
    public void shouldThrowExceptionMessageWhenFailToGenerateBls12381G1Key() {
        byte[] seed = null;

        try {
            Bbs.generateBls12381G1Key(seed);
            fail("Expected an exception to be thrown");
        } catch (Exception exception) {
            assertEquals("Unable to generate keys", exception.getMessage());
        }
    }

    @Test
    public void canGenerateBls12381G2Key() {
        byte[] seed = new byte[0];
        KeyPair keyPair = null;

        try {
            keyPair = Bbs.generateBls12381G2Key(seed);
        } catch (Exception exception) {
            exception.printStackTrace();
        }

        assertNotNull(keyPair);
        assertEquals(keyPair.publicKey.length, Bbs.getBls12381G2PublicKeySize());
        assertEquals(keyPair.secretKey.length, Bbs.getSecretKeySize());
    }

    @Test
    public void shouldThrowExceptionMessageWhenFailToGenerateBls12381G2Key() {
        byte[] seed = null;

        try {
            Bbs.generateBls12381G2Key(seed);
            fail("Expected an exception to be thrown");
        } catch (Exception exception) {
            assertEquals("Unable to generate keys", exception.getMessage());
        }
    }

    @Test
    public void canGenerateBlindedBls12381G1Key() {
        byte[] seed = new byte[0];
        BlindedKeyPair keyPair = null;

        try {
            keyPair = Bbs.generateBlindedBls12381G1Key(seed);
        } catch (Exception exception) {
            exception.printStackTrace();
        }

        assertNotNull(keyPair);
        assertEquals(keyPair.publicKey.length, Bbs.getBls12381G1PublicKeySize());
        assertEquals(keyPair.secretKey.length, Bbs.getBls12381G1PublicKeySize()); // TODO Check secretKey size, expected 48, method returns 32
    }

    @Test
    public void shouldThrowExceptionMessageWhenFailToGenerateBlindedBls12381G1Key() {
        byte[] seed = null;

        try {
            Bbs.generateBlindedBls12381G1Key(seed);
            fail("Expected an exception to be thrown");
        } catch (Exception exception) {
            assertEquals("Unable to generate keys", exception.getMessage());
        }
    }

    @Test
    public void canGenerateBlindedBls12381G2Key() {
        byte[] seed = new byte[0];
        BlindedKeyPair keyPair = null;

        try {
            keyPair = Bbs.generateBlindedBls12381G2Key(seed);
        } catch (Exception exception) {
            exception.printStackTrace();
        }

        assertNotNull(keyPair);
        assertEquals(keyPair.publicKey.length, Bbs.getBls12381G2PublicKeySize());
        assertEquals(keyPair.secretKey.length, Bbs.getBls12381G2PublicKeySize()); // TODO Check secretKey size, expected 96, method returns 48
    }

    @Test
    public void shouldThrowExceptionMessageWhenFailToGenerateBlindedBls12381G2Key() {
        byte[] seed = null;

        try {
            Bbs.generateBlindedBls12381G2Key(seed);
            fail("Expected an exception to be thrown");
        } catch (Exception exception) {
            assertEquals("Unable to generate keys", exception.getMessage());
        }
    }

    @Test public void canSignMessage() {
        byte[] seed = new byte[0];
        KeyPair keyPair = null;

        try {
            keyPair = Bbs.generateBls12381G2Key(seed);
        } catch (Exception exception) {
            exception.printStackTrace();
        }

        assertNotNull(keyPair);

        byte[] bbsKey = Bbs.blsPublicToBbsPublicKey(keyPair.publicKey, 1);
        byte[] secretKey = keyPair.secretKey;

        byte[] signature = new byte[Bbs.getSignatureSize()];
        byte[][] messages = {"message1".getBytes()};

        try {
            signature = Bbs.sign(secretKey, bbsKey, messages);
        } catch (Exception exception) {
            exception.printStackTrace();
        }

        assertNotNull(signature);
    }

    @Test public void canVerifyMessage() {
        byte[] seed = new byte[0];
        KeyPair keyPair = null;

        try {
            keyPair = Bbs.generateBls12381G2Key(seed);
        } catch (Exception exception) {
            exception.printStackTrace();
        }

        assertNotNull(keyPair);

        byte[] bbsKey = Bbs.blsPublicToBbsPublicKey(keyPair.publicKey, 1);
        byte[] secretKey = keyPair.secretKey;

        byte[] signature = new byte[Bbs.getSignatureSize()];
        byte[][] messages = {"message1".getBytes()};

        try {
            signature = Bbs.sign(secretKey, bbsKey, messages);
        } catch (Exception exception) {
            exception.printStackTrace();
        }

        assertNotNull(signature);

        boolean isVerified = false;

        try {
            isVerified = Bbs.verify(bbsKey, signature, messages);
        } catch (Exception exception) {
            exception.printStackTrace();
        }

        assertTrue(isVerified);
    }

    @Test
    public void shouldThrowExceptionMessageWhenVerificationPublicKeyIsInvalid() {
        byte[] invalidPublicKey = new byte[96];
        byte[][] messages = {"message1".getBytes()};
        byte[] signature = new byte[112];

        try {
            Bbs.verify(invalidPublicKey, signature, messages);
            fail("Expected an exception to be thrown");
        } catch (Exception exception) {
            assertEquals("Unable to set public key", exception.getMessage());
        }
    }

    @Test
    public void shouldThrowExceptionMessageWhenVerificationSignatureIsInvalid() {
        byte[] seed = new byte[0];
        KeyPair keyPair = null;

        try {
            keyPair = Bbs.generateBls12381G2Key(seed);
        } catch (Exception exception) {
            exception.printStackTrace();
        }

        assertNotNull(keyPair);

        byte[] bbsKey = Bbs.blsPublicToBbsPublicKey(keyPair.publicKey, 1);
        byte[] invalidSignature = new byte[112];
        byte[][] messages = {"message1".getBytes()};

        try {
            Bbs.verify(bbsKey, invalidSignature, messages);
            fail("Expected an exception to be thrown");
        } catch (Exception exception) {
            assertEquals("Unable to set signature", exception.getMessage());
        }
    }

    @Test
    public void shouldThrowExceptionMessageWhenSignAddVerificationMessage() {
        byte[] seed = new byte[0];
        KeyPair keyPair = null;

        try {
            keyPair = Bbs.generateBls12381G2Key(seed);
        } catch (Exception exception) {
            exception.printStackTrace();
        }

        assertNotNull(keyPair);

        byte[] bbsKey = Bbs.blsPublicToBbsPublicKey(keyPair.publicKey, 1);
        byte[] secretKey = keyPair.secretKey;
        byte[] signature = new byte[112];
        byte[][] messages = {"message1".getBytes()};

        try {
            signature = Bbs.sign(secretKey, bbsKey, messages);
        } catch (Exception exception) {
            exception.printStackTrace();
        }

        assertNotNull(signature);

        try {
            Bbs.verify(bbsKey, signature, messages);
            //fail("Expected an exception to be thrown");
        } catch (Exception exception) {
            // TODO How to cause exception ? bbs_sign_context_add_message_bytes not found
            assertEquals("Unable to add message", exception.getMessage());
        }
    }

    @Test
    public void shouldThrowExceptionMessageWhenUnableToVerifySignature() {
        byte[] seed = new byte[0];
        KeyPair keyPair = null;

        try {
            keyPair = Bbs.generateBls12381G2Key(seed);
        } catch (Exception exception) {
            exception.printStackTrace();
        }

        assertNotNull(keyPair);

        byte[] bbsKey = Bbs.blsPublicToBbsPublicKey(keyPair.publicKey, 1);
        byte[] secretKey = keyPair.secretKey;
        byte[] signature = new byte[112];
        byte[][] messages = {"message1".getBytes()};

        try {
            signature = Bbs.sign(secretKey, bbsKey, messages);
        } catch (Exception exception) {
            exception.printStackTrace();
        }

        assertNotNull(signature);

        try {
            Bbs.verify(bbsKey, signature, messages);
            //fail("Expected an exception to be thrown");
        } catch (Exception exception) {
            // TODO How to cause exception ? bbs_verify_set_signature verifies the signature
            assertEquals("Unable to verify signature", exception.getMessage());
        }
    }

    @Test
    public void canCreateBlindCommitment() {
        byte[] seed = new byte[0];
        KeyPair keyPair = null;

        try {
            keyPair = Bbs.generateBls12381G2Key(seed);
        } catch (Exception exception) {
            exception.printStackTrace();
        }

        assertNotNull(keyPair);

        byte[] bbsKey = Bbs.blsPublicToBbsPublicKey(keyPair.publicKey, 1);
        byte[] nonce = new byte[32];
        Map<Integer, byte[]> messages = Map.of(0, "message1".getBytes());

        BlindCommitmentContext context = null;

        try {
            context = Bbs.blindCommitment(bbsKey, messages, nonce);
        } catch (Exception exception) {
            exception.printStackTrace();
        }

        assertNotNull(context);
    }

    @Test
    public void shouldThrowExceptionMessageWhenBlindCommitmentPublicKeyIsInvalid() {
        byte[] invalidPublicKey = new byte[96];
        byte[] nonce = new byte[32];
        Map<Integer, byte[]> messages = Collections.emptyMap();

        try {
            Bbs.blindCommitment(invalidPublicKey, messages, nonce);
            fail("Expected an exception to be thrown");
        } catch (Exception exception) {
            assertEquals("Unable to set public key", exception.getMessage());
        }
    }

    @Test
    public void shouldThrowExceptionMessageWhenBlindCommitmentNonceIsInvalid() {
        byte[] seed = new byte[0];
        KeyPair keyPair = null;

        try {
            keyPair = Bbs.generateBls12381G2Key(seed);
        } catch (Exception exception) {
            exception.printStackTrace();
        }

        assertNotNull(keyPair);

        byte[] bbsKey = Bbs.blsPublicToBbsPublicKey(keyPair.publicKey, 1);
        byte[] invalidNonce = null;
        Map<Integer, byte[]> messages = Collections.emptyMap();

        try {
            Bbs.blindCommitment(bbsKey, messages, invalidNonce);
            fail("Expected an exception to be thrown");
        } catch (Exception exception) {
            assertEquals("Unable to set nonce", exception.getMessage());
        }
    }

    @Test
    public void shouldThrowExceptionMessageWhenBlindCommitmentMessageIsInvalid() {
        byte[] seed = new byte[0];
        KeyPair keyPair = null;

        try {
            keyPair = Bbs.generateBls12381G2Key(seed);
        } catch (Exception exception) {
            exception.printStackTrace();
        }

        assertNotNull(keyPair);

        byte[] bbsKey = Bbs.blsPublicToBbsPublicKey(keyPair.publicKey, 1);
        byte[] nonce = new byte[32];
        Map<Integer, byte[]> invalidMessages = Map.of(0, "".getBytes());

        try {
            Bbs.blindCommitment(bbsKey, invalidMessages, nonce);
            fail("Expected an exception to be thrown");
        } catch (Exception exception) {
            assertEquals("Unable to add message", exception.getMessage());
        }
    }

    @Test public void canBlindSign() {
        byte[] seed = new byte[0];
        KeyPair keyPair = null;

        try {
            keyPair = Bbs.generateBls12381G2Key(seed);
        } catch (Exception exception) {
            exception.printStackTrace();
        }

        assertNotNull(keyPair);

        byte[] bbsKey = Bbs.blsPublicToBbsPublicKey(keyPair.publicKey, 1);
        byte[] secretKey = new byte[32];
        byte[] nonce = new byte[32];
        Map<Integer, byte[]> messages = Map.of(0, "message1".getBytes());

        BlindCommitmentContext blindCommitmentContext = null;

        try {
            blindCommitmentContext = Bbs.blindCommitment(bbsKey, messages, nonce);
        } catch (Exception exception) {
            exception.printStackTrace();
        }

        assertNotNull(blindCommitmentContext);

        byte[] blindSignature = new byte[112];

        try {
            blindSignature = Bbs.blindSign(secretKey, bbsKey, blindCommitmentContext.commitment, messages);
        } catch (Exception exception) {
            exception.printStackTrace();
        }

        assertNotNull(blindSignature);
    }

    @Test
    public void shouldThrowExceptionMessageWhenBlindSignSecretKeyIsInvalid() {
        byte[] publicKey = new byte[96];
        byte[] invalidSecretKey = null;
        byte[] commitment = new byte[48];
        Map<Integer, byte[]> messages = Collections.emptyMap();

        try {
            Bbs.blindSign(invalidSecretKey, publicKey, commitment, messages);
            fail("Expected an exception to be thrown");
        } catch (Exception exception) {
            assertEquals("Unable to set secret key", exception.getMessage());
        }
    }

    @Test
    public void shouldThrowExceptionMessageWhenBlindSignPublicKeyIsInvalid() {
        byte[] publicKey = new byte[96];
        byte[] secretKey = new byte[32];
        byte[] commitment = new byte[48];
        Map<Integer, byte[]> messages = Collections.emptyMap();

        try {
            Bbs.blindSign(secretKey, publicKey, commitment, messages);
            fail("Expected an exception to be thrown");
        } catch (Exception exception) {
            assertEquals("Unable to set public key", exception.getMessage());
        }
    }

    @Test
    public void shouldThrowExceptionMessageWhenBlindSignCommitmentIsInvalid() {
        byte[] seed = new byte[0];
        KeyPair keyPair = null;

        try {
            keyPair = Bbs.generateBls12381G2Key(seed);
        } catch (Exception exception) {
            exception.printStackTrace();
        }

        assertNotNull(keyPair);

        byte[] bbsKey = Bbs.blsPublicToBbsPublicKey(keyPair.publicKey, 1);
        byte[] secretKey = new byte[32];
        byte[] invalidCommitment = new byte[48];
        Map<Integer, byte[]> messages = Collections.emptyMap();

        try {
            Bbs.blindSign(secretKey, bbsKey, invalidCommitment, messages);
            fail("Expected an exception to be thrown");
        } catch (Exception exception) {
            assertEquals("Unable to set commitment", exception.getMessage());
        }
    }

    @Test
    public void shouldThrowExceptionMessageWhenBlindSignMessageIsInvalid() {
        byte[] seed = new byte[0];
        KeyPair keyPair = null;

        try {
            keyPair = Bbs.generateBls12381G2Key(seed);
        } catch (Exception exception) {
            exception.printStackTrace();
        }

        assertNotNull(keyPair);

        byte[] bbsKey = Bbs.blsPublicToBbsPublicKey(keyPair.publicKey, 1);
        byte[] secretKey = new byte[32];
        byte[] nonce = new byte[32];
        Map<Integer, byte[]> messages = Map.of(0, "message1".getBytes());

        BlindCommitmentContext blindCommitmentContext = null;

        try {
            blindCommitmentContext = Bbs.blindCommitment(bbsKey, messages, nonce);
        } catch (Exception exception) {
            exception.printStackTrace();
        }

        assertNotNull(blindCommitmentContext);

        Map<Integer, byte[]> invalidMessages = Map.of(0, "".getBytes());

        try {
            Bbs.blindSign(secretKey, bbsKey, blindCommitmentContext.commitment, invalidMessages);
            fail("Expected an exception to be thrown");
        } catch (Exception exception) {
            assertEquals("Unable to add message", exception.getMessage());
        }
    }

    @Test
    public void canUnblindSignature() {
        byte[] blindSignature = new byte[112];
        byte[] blindingFactor = new byte[32];
        byte[] signature;

        signature = Bbs.unblindSignature(blindSignature, blindingFactor);
        assertNotNull(signature);
    }

    @Test
    public void shouldReturnNullWhenCantUnblindSignature() {
        byte[] blindSignature = null;
        byte[] blindingFactor = null;
        byte[] signature;

        signature = Bbs.unblindSignature(blindSignature, blindingFactor);
        assertNull("The signature is null", signature);
    }

    @Test
    public void canCreateProof() {
        byte[] seed = new byte[0];
        KeyPair keyPair = null;

        try {
            keyPair = Bbs.generateBls12381G2Key(seed);
        } catch (Exception exception) {
            exception.printStackTrace();
        }

        assertNotNull(keyPair);

        byte[] bbsKey = Bbs.blsPublicToBbsPublicKey(keyPair.publicKey, 1);
        byte[] nonce = new byte[32];
        byte[] signature = new byte[112];

        int type = 1;
        byte[] blindingFactor = new byte[Bbs.getBlindingFactorSize()];
        byte[] message = new byte[96];
        ProofMessage[] proofMessage = new ProofMessage[]{
                new ProofMessage(type, message, blindingFactor),
        };

        byte[] proof = new byte[0];

        try {
            proof = Bbs.createProof(bbsKey, nonce, signature, proofMessage);
        } catch (Exception exception) {
            exception.printStackTrace();
        }

        assertNotNull(proof);
    }

//    @Test
//    public void shouldThrowExceptionMessageWhenProofPublicKeyIsInvalid() {
//        byte[] public_key = new byte[96];
//        byte[] nonce = new byte[32];
//        byte[] signature = new byte[96];
//
//        int type = 1;
//        byte[] blinding_factor = new byte[Bbs.getBlindingFactorSize()];
//        byte[] message = new byte[96];
//        ProofMessage[] proofMessage = new ProofMessage[] {
//                new ProofMessage(type, message, blinding_factor),
//        };
//
//        byte[] proof = new byte[0];
//
//        try {
//            proof = Bbs.createProof(public_key, nonce, signature, proofMessage);
//            fail("Expected an exception to be thrown");
//        } catch (Exception exception) {
//            assertEquals("Unable to set public key", exception.getMessage());
//        }
//    }
//
//    @Test
//    public void shouldThrowExceptionMessageWhenProofNonceIsInvalid() {
//        byte[] public_key = new byte[96];
//        byte[] nonce = new byte[32];
//        byte[] signature = new byte[96];
//
//        int type = 1;
//        byte[] blinding_factor = new byte[Bbs.getBlindingFactorSize()];
//        byte[] message = new byte[96];
//        ProofMessage[] proofMessage = new ProofMessage[] {
//                new ProofMessage(type, message, blinding_factor),
//        };
//
//        byte[] proof = new byte[0];
//
//        try {
//            proof = Bbs.createProof(public_key, nonce, signature, proofMessage);
//            fail("Expected an exception to be thrown");
//        } catch (Exception exception) {
//            assertEquals("Unable to set nonce", exception.getMessage());
//        }
//    }
//
//    @Test
//    public void shouldThrowExceptionMessageWhenProofSignatureIsInvalid() {
//        byte[] public_key = new byte[96];
//        byte[] nonce = new byte[32];
//        byte[] signature = new byte[96];
//
//        int type = 1;
//        byte[] blinding_factor = new byte[Bbs.getBlindingFactorSize()];
//        byte[] message = new byte[96];
//        ProofMessage[] proofMessage = new ProofMessage[] {
//                new ProofMessage(type, message, blinding_factor),
//        };
//
//        byte[] proof = new byte[0];
//
//        try {
//            proof = Bbs.createProof(public_key, nonce, signature, proofMessage);
//            fail("Expected an exception to be thrown");
//        } catch (Exception exception) {
//            assertEquals("Unable to set signature", exception.getMessage());
//        }
//    }
//
//    @Test
//    public void shouldThrowExceptionMessageWhenProofMessageIsInvalid() {
//        byte[] public_key = new byte[96];
//        byte[] nonce = new byte[32];
//        byte[] signature = new byte[96];
//
//        int type = 1;
//        byte[] blinding_factor = new byte[Bbs.getBlindingFactorSize()];
//        byte[] message = new byte[96];
//        ProofMessage[] proofMessage = new ProofMessage[] {
//                new ProofMessage(type, message, blinding_factor),
//        };
//
//        byte[] proof = new byte[0];
//
//        try {
//            proof = Bbs.createProof(public_key, nonce, signature, proofMessage);
//            fail("Expected an exception to be thrown");
//        } catch (Exception exception) {
//            assertEquals("Unable to add proof message", exception.getMessage());
//        }
//    }
//
//    @Test
//    public void shouldThrowExceptionMessageWhenUnableToCreateProof() {
//        byte[] public_key = new byte[96];
//        byte[] nonce = new byte[32];
//        byte[] signature = new byte[96];
//
//        int type = 1;
//        byte[] blinding_factor = new byte[Bbs.getBlindingFactorSize()];
//        byte[] message = new byte[96];
//        ProofMessage[] proofMessage = new ProofMessage[] {
//                new ProofMessage(type, message, blinding_factor),
//        };
//
//        byte[] proof = new byte[0];
//
//        try {
//            proof = Bbs.createProof(public_key, nonce, signature, proofMessage);
//            fail("Expected an exception to be thrown");
//        } catch (Exception exception) {
//            assertEquals("Unable to create proof", exception.getMessage());
//        }
//    }
}
