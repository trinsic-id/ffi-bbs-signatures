/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package bbs.signatures;

import org.junit.Test;

import java.util.Collections;
import java.util.Map;
import java.util.HashMap;

import static org.junit.Assert.*;

public class BbsSignatureTest {

    public KeyPair keyPair;

    @Test
    public void canGetCorrectBls12381G1PublicKeySize() {
        int size = Bbs.getBls12381G1PublicKeySize();
        assertEquals(size, 48);
    }

    @Test
    public void canGetCorrectBls12381G2PublicKeySize() {
        int size = Bbs.getBls12381G2PublicKeySize();
        assertEquals(size, 96);
    }

    @Test
    public void canGetSecretKeySize() {
        int size = Bbs.getSecretKeySize();
        assertEquals(size, 32);
    }

    @Test
    public void canGetSignatureSize() {
        int size = Bbs.getSignatureSize();
        assertEquals(size, 112);
    }

    @Test
    public void canGetBlindSignatureSize() {
        int size = Bbs.getBlindSignatureSize();
        assertEquals(size, 112);
    }

    @Test
    public void canGenerateBls12381G1Key() {
        byte[] seed = new byte[0];
        KeyPair keyPair = null;

        try {
            keyPair = Bbs.generateBls12381G1Key(seed);
        } catch (Exception exception) {
            exception.printStackTrace();
        }

        assertNotNull(keyPair);
        assertEquals(keyPair.publicKey.length, Bbs.getBls12381G1PublicKeySize());
        assertEquals(keyPair.secretKey.length, Bbs.getSecretKeySize());
    }

    @Test
    public void shouldThrowExceptionMessageWhenFailToGenerateBls12381G1Key() {
        byte[] seed = null;

        try {
            Bbs.generateBls12381G1Key(seed);
            fail("Expected an exception to be thrown");
        } catch (Exception exception) {
            assertEquals("Unable to generate keys", exception.getMessage());
        }
    }

    @Test
    public void canGenerateBls12381G2Key() {
        byte[] seed = new byte[0];
        KeyPair keyPair = null;

        try {
            keyPair = Bbs.generateBls12381G2Key(seed);
        } catch (Exception exception) {
            exception.printStackTrace();
        }

        assertNotNull(keyPair);
        assertEquals(keyPair.publicKey.length, Bbs.getBls12381G2PublicKeySize());
        assertEquals(keyPair.secretKey.length, Bbs.getSecretKeySize());
    }

    @Test
    public void shouldThrowExceptionMessageWhenFailToGenerateBls12381G2Key() {
        byte[] seed = null;

        try {
            Bbs.generateBls12381G2Key(seed);
            fail("Expected an exception to be thrown");
        } catch (Exception exception) {
            assertEquals("Unable to generate keys", exception.getMessage());
        }
    }

    @Test
    public void canGenerateBlindedBls12381G1Key() {
        byte[] seed = new byte[0];
        BlindedKeyPair keyPair = null;

        try {
            keyPair = Bbs.generateBlindedBls12381G1Key(seed);
        } catch (Exception exception) {
            exception.printStackTrace();
        }

        assertNotNull(keyPair);
        assertEquals(keyPair.publicKey.length, Bbs.getBls12381G1PublicKeySize());
        assertEquals(keyPair.secretKey.length, Bbs.getBls12381G1PublicKeySize()); // TODO Check secretKey size, expected 48, method returns 32
    }

    @Test
    public void shouldThrowExceptionMessageWhenFailToGenerateBlindedBls12381G1Key() {
        byte[] seed = null;

        try {
            Bbs.generateBlindedBls12381G1Key(seed);
            fail("Expected an exception to be thrown");
        } catch (Exception exception) {
            assertEquals("Unable to generate keys", exception.getMessage());
        }
    }

    @Test
    public void canGenerateBlindedBls12381G2Key() {
        byte[] seed = new byte[0];
        BlindedKeyPair keyPair = null;

        try {
            keyPair = Bbs.generateBlindedBls12381G2Key(seed);
        } catch (Exception exception) {
            exception.printStackTrace();
        }

        assertNotNull(keyPair);
        assertEquals(keyPair.publicKey.length, Bbs.getBls12381G2PublicKeySize());
        assertEquals(keyPair.secretKey.length, Bbs.getBls12381G2PublicKeySize()); // TODO Check secretKey size, expected 96, method returns 48
    }

    @Test
    public void shouldThrowExceptionMessageWhenFailToGenerateBlindedBls12381G2Key() {
        byte[] seed = null;

        try {
            Bbs.generateBlindedBls12381G2Key(seed);
            fail("Expected an exception to be thrown");
        } catch (Exception exception) {
            assertEquals("Unable to generate keys", exception.getMessage());
        }
    }

    @Test public void canSignMessage() {
        byte[] seed = new byte[0];
        KeyPair keyPair = null;

        try {
            keyPair = Bbs.generateBls12381G2Key(seed);
        } catch (Exception exception) {
            exception.printStackTrace();
        }

        assertNotNull(keyPair);

        byte[] bbsKey = Bbs.blsPublicToBbsPublicKey(keyPair.publicKey, 1);
        byte[] secretKey = keyPair.secretKey;

        byte[] signature = new byte[Bbs.getSignatureSize()];
        byte[][] messages = {"message1".getBytes()};

        try {
            signature = Bbs.sign(secretKey, bbsKey, messages);
        } catch (Exception exception) {
            exception.printStackTrace();
        }

        assertNotNull(signature);
    }

    @Test public void canVerifyMessage() {
        byte[] seed = new byte[0];
        KeyPair keyPair = null;

        try {
            keyPair = Bbs.generateBls12381G2Key(seed);
        } catch (Exception exception) {
            exception.printStackTrace();
        }

        assertNotNull(keyPair);

        byte[] bbsKey = Bbs.blsPublicToBbsPublicKey(keyPair.publicKey, 1);
        byte[] secretKey = keyPair.secretKey;

        byte[] signature = new byte[Bbs.getSignatureSize()];
        byte[][] messages = {"message1".getBytes()};

        try {
            signature = Bbs.sign(secretKey, bbsKey, messages);
        } catch (Exception exception) {
            exception.printStackTrace();
        }

        assertNotNull(signature);

        boolean isVerified = false;

        try {
            isVerified = Bbs.verify(bbsKey, signature, messages);
        } catch (Exception exception) {
            exception.printStackTrace();
        }

        assertTrue(isVerified);
    }

    @Test
    public void shouldThrowExceptionMessageWhenVerificationPublicKeyIsInvalid() {
        byte[] invalidPublicKey = new byte[96];
        byte[][] messages = {"message1".getBytes()};
        byte[] signature = new byte[112];

        try {
            Bbs.verify(invalidPublicKey, signature, messages);
            fail("Expected an exception to be thrown");
        } catch (Exception exception) {
            assertEquals("Unable to set public key", exception.getMessage());
        }
    }

    @Test
    public void shouldThrowExceptionMessageWhenVerificationSignatureIsInvalid() {
        byte[] seed = new byte[0];
        KeyPair keyPair = null;

        try {
            keyPair = Bbs.generateBls12381G2Key(seed);
        } catch (Exception exception) {
            exception.printStackTrace();
        }

        assertNotNull(keyPair);

        byte[] bbsKey = Bbs.blsPublicToBbsPublicKey(keyPair.publicKey, 1);
        byte[] invalidSignature = new byte[112];
        byte[][] messages = {"message1".getBytes()};

        try {
            Bbs.verify(bbsKey, invalidSignature, messages);
            fail("Expected an exception to be thrown");
        } catch (Exception exception) {
            assertEquals("Unable to set signature", exception.getMessage());
        }
    }

    @Test
    public void shouldThrowExceptionMessageWhenSignAddVerificationMessage() {
        byte[] seed = new byte[0];
        KeyPair keyPair = null;

        try {
            keyPair = Bbs.generateBls12381G2Key(seed);
        } catch (Exception exception) {
            exception.printStackTrace();
        }

        assertNotNull(keyPair);

        byte[] bbsKey = Bbs.blsPublicToBbsPublicKey(keyPair.publicKey, 1);
        byte[] secretKey = keyPair.secretKey;
        byte[] signature = new byte[112];
        byte[][] messages = {"message1".getBytes()};

        try {
            signature = Bbs.sign(secretKey, bbsKey, messages);
        } catch (Exception exception) {
            exception.printStackTrace();
        }

        assertNotNull(signature);

        try {
            Bbs.verify(bbsKey, signature, messages);
            //fail("Expected an exception to be thrown");
        } catch (Exception exception) {
            // TODO How to cause exception ? bbs_sign_context_add_message_bytes not found
            assertEquals("Unable to add message", exception.getMessage());
        }
    }

    @Test
    public void shouldThrowExceptionMessageWhenUnableToVerifySignature() {
        byte[] seed = new byte[0];
        KeyPair keyPair = null;

        try {
            keyPair = Bbs.generateBls12381G2Key(seed);
        } catch (Exception exception) {
            exception.printStackTrace();
        }

        assertNotNull(keyPair);

        byte[] bbsKey = Bbs.blsPublicToBbsPublicKey(keyPair.publicKey, 1);
        byte[] secretKey = keyPair.secretKey;
        byte[] signature = new byte[112];
        byte[][] messages = {"message1".getBytes()};

        try {
            signature = Bbs.sign(secretKey, bbsKey, messages);
        } catch (Exception exception) {
            exception.printStackTrace();
        }

        assertNotNull(signature);

        try {
            Bbs.verify(bbsKey, signature, messages);
            //fail("Expected an exception to be thrown");
        } catch (Exception exception) {
            // TODO How to cause exception ? bbs_verify_set_signature verifies the signature
            assertEquals("Unable to verify signature", exception.getMessage());
        }
    }

    @Test
    public void canCreateBlindCommitment() {
        byte[] seed = new byte[0];
        KeyPair keyPair = null;

        try {
            keyPair = Bbs.generateBls12381G2Key(seed);
        } catch (Exception exception) {
            exception.printStackTrace();
        }

        assertNotNull(keyPair);

        byte[] bbsKey = Bbs.blsPublicToBbsPublicKey(keyPair.publicKey, 1);
        byte[] nonce = new byte[32];
        Map<Integer, byte[]> messages = new HashMap<Integer, byte[]>() {{
            put(0, "message1".getBytes());
        }};

        BlindCommitmentContext context = null;

        try {
            context = Bbs.blindCommitment(bbsKey, messages, nonce);
        } catch (Exception exception) {
            exception.printStackTrace();
        }

        assertNotNull(context);
    }

    @Test
    public void shouldThrowExceptionMessageWhenBlindCommitmentPublicKeyIsInvalid() {
        byte[] invalidPublicKey = new byte[96];
        byte[] nonce = new byte[32];
        Map<Integer, byte[]> messages = Collections.emptyMap();

        try {
            Bbs.blindCommitment(invalidPublicKey, messages, nonce);
            fail("Expected an exception to be thrown");
        } catch (Exception exception) {
            assertEquals("Unable to set public key", exception.getMessage());
        }
    }

    @Test
    public void shouldThrowExceptionMessageWhenBlindCommitmentNonceIsInvalid() {
        byte[] seed = new byte[0];
        KeyPair keyPair = null;

        try {
            keyPair = Bbs.generateBls12381G2Key(seed);
        } catch (Exception exception) {
            exception.printStackTrace();
        }

        assertNotNull(keyPair);

        byte[] bbsKey = Bbs.blsPublicToBbsPublicKey(keyPair.publicKey, 1);
        byte[] invalidNonce = null;
        Map<Integer, byte[]> messages = Collections.emptyMap();

        try {
            Bbs.blindCommitment(bbsKey, messages, invalidNonce);
            fail("Expected an exception to be thrown");
        } catch (Exception exception) {
            assertEquals("Unable to set nonce", exception.getMessage());
        }
    }

    @Test
    public void shouldThrowExceptionMessageWhenBlindCommitmentMessageIsInvalid() {
        byte[] seed = new byte[0];
        KeyPair keyPair = null;

        try {
            keyPair = Bbs.generateBls12381G2Key(seed);
        } catch (Exception exception) {
            exception.printStackTrace();
        }

        assertNotNull(keyPair);

        byte[] bbsKey = Bbs.blsPublicToBbsPublicKey(keyPair.publicKey, 1);
        byte[] nonce = new byte[32];
        Map<Integer, byte[]> invalidMessages = new HashMap<Integer, byte[]>() {{
            put(0, "".getBytes());
        }};

        try {
            Bbs.blindCommitment(bbsKey, invalidMessages, nonce);
            fail("Expected an exception to be thrown");
        } catch (Exception exception) {
            assertEquals("Unable to add message", exception.getMessage());
        }
    }

    @Test public void canBlindSign() {
        byte[] seed = new byte[0];
        KeyPair keyPair = null;

        try {
            keyPair = Bbs.generateBls12381G2Key(seed);
        } catch (Exception exception) {
            exception.printStackTrace();
        }

        assertNotNull(keyPair);

        byte[] bbsKey = Bbs.blsPublicToBbsPublicKey(keyPair.publicKey, 1);
        byte[] secretKey = new byte[32];
        byte[] nonce = new byte[32];
        Map<Integer, byte[]> messages = new HashMap<Integer, byte[]>() {{
            put(0, "message1".getBytes());
        }};

        BlindCommitmentContext blindCommitmentContext = null;

        try {
            blindCommitmentContext = Bbs.blindCommitment(bbsKey, messages, nonce);
        } catch (Exception exception) {
            exception.printStackTrace();
        }

        assertNotNull(blindCommitmentContext);

        byte[] blindSignature = new byte[112];

        try {
            blindSignature = Bbs.blindSign(secretKey, bbsKey, blindCommitmentContext.commitment, messages);
        } catch (Exception exception) {
            exception.printStackTrace();
        }

        assertNotNull(blindSignature);
    }

    @Test
    public void shouldThrowExceptionMessageWhenBlindSignSecretKeyIsInvalid() {
        byte[] publicKey = new byte[96];
        byte[] invalidSecretKey = null;
        byte[] commitment = new byte[48];
        Map<Integer, byte[]> messages = Collections.emptyMap();

        try {
            Bbs.blindSign(invalidSecretKey, publicKey, commitment, messages);
            fail("Expected an exception to be thrown");
        } catch (Exception exception) {
            assertEquals("Unable to set secret key", exception.getMessage());
        }
    }

    @Test
    public void shouldThrowExceptionMessageWhenBlindSignPublicKeyIsInvalid() {
        byte[] publicKey = new byte[96];
        byte[] secretKey = new byte[32];
        byte[] commitment = new byte[48];
        Map<Integer, byte[]> messages = Collections.emptyMap();

        try {
            Bbs.blindSign(secretKey, publicKey, commitment, messages);
            fail("Expected an exception to be thrown");
        } catch (Exception exception) {
            assertEquals("Unable to set public key", exception.getMessage());
        }
    }

    @Test
    public void shouldThrowExceptionMessageWhenBlindSignCommitmentIsInvalid() {
        byte[] seed = new byte[0];
        KeyPair keyPair = null;

        try {
            keyPair = Bbs.generateBls12381G2Key(seed);
        } catch (Exception exception) {
            exception.printStackTrace();
        }

        assertNotNull(keyPair);

        byte[] bbsKey = Bbs.blsPublicToBbsPublicKey(keyPair.publicKey, 1);
        byte[] secretKey = new byte[32];
        byte[] invalidCommitment = new byte[48];
        Map<Integer, byte[]> messages = Collections.emptyMap();

        try {
            Bbs.blindSign(secretKey, bbsKey, invalidCommitment, messages);
            fail("Expected an exception to be thrown");
        } catch (Exception exception) {
            assertEquals("Unable to set commitment", exception.getMessage());
        }
    }

    @Test
    public void shouldThrowExceptionMessageWhenBlindSignMessageIsInvalid() {
        byte[] seed = new byte[0];
        KeyPair keyPair = null;

        try {
            keyPair = Bbs.generateBls12381G2Key(seed);
        } catch (Exception exception) {
            exception.printStackTrace();
        }

        assertNotNull(keyPair);

        byte[] bbsKey = Bbs.blsPublicToBbsPublicKey(keyPair.publicKey, 1);
        byte[] secretKey = new byte[32];
        byte[] nonce = new byte[32];
        Map<Integer, byte[]> messages = new HashMap<Integer, byte[]>() {{
            put(0, "message1".getBytes());
        }};

        BlindCommitmentContext blindCommitmentContext = null;

        try {
            blindCommitmentContext = Bbs.blindCommitment(bbsKey, messages, nonce);
        } catch (Exception exception) {
            exception.printStackTrace();
        }

        assertNotNull(blindCommitmentContext);

        Map<Integer, byte[]> invalidMessages = new HashMap<Integer, byte[]>() {{
            put(0, "".getBytes());
        }};

        try {
            Bbs.blindSign(secretKey, bbsKey, blindCommitmentContext.commitment, invalidMessages);
            fail("Expected an exception to be thrown");
        } catch (Exception exception) {
            assertEquals("Unable to add message", exception.getMessage());
        }
    }

    @Test
    public void canUnblindSignature() {
        byte[] blindSignature = new byte[112];
        byte[] blindingFactor = new byte[32];
        byte[] signature;

        signature = Bbs.unblindSignature(blindSignature, blindingFactor);
        assertNotNull(signature);
    }

    @Test
    public void shouldReturnNullWhenCantUnblindSignature() {
        byte[] blindSignature = null;
        byte[] blindingFactor = null;
        byte[] signature;

        signature = Bbs.unblindSignature(blindSignature, blindingFactor);
        assertNull("The signature is null", signature);
    }

    @Test public void testBlsCreateProofRevealingSingleMessageFromSingleMessageSignature() {
        byte[] nonce = java.util.Base64.getDecoder().decode("MDEyMzQ1Njc4OQ==");
        byte[] message = java.util.Base64.getDecoder().decode("dXpBb1FGcUxnUmVpZHc9PQ==");
        byte[] publicKey = java.util.Base64.getDecoder().decode("qJgttTOthlZHltz+c0PE07hx3worb/cy7QY5iwRegQ9BfwvGahdqCO9Q9xuOnF5nD/Tq6t8zm9z26EAFCiaEJnL5b50D1cHDgNxBUPEEae+4bUb3JRsHaxBdZWDOo3pb");
        byte[] signature = java.util.Base64.getDecoder().decode("r00WeXEj+07DUZb3JY6fbbKhHtQcxtLZsJUVU6liFZQKCLQYu77EXFZx4Vaa5VBtKpPK6tDGovHGgrgyizOm70VUZgzzBb0emvRIGSWhAKkcLL1z1HYwApnUE6XFFb96LUF4XM//QhEM774dX4ciqQ==");

        int type = 1;
        byte[] blindingFactor = new byte[0];
        ProofMessage[] proofMessage = new ProofMessage[]{
                new ProofMessage(type, message, blindingFactor),
        };

        byte[] proof = new byte[0];
        byte[] bbsKey = Bbs.blsPublicToBbsPublicKey(publicKey, 1);

        try {
            proof = Bbs.createProof(bbsKey, nonce, signature, proofMessage);
        } catch (Exception exception) {
            exception.printStackTrace();
        }

        assertNotNull(proof);
    }

    @Test
    public void shouldThrowExceptionMessageWhenProofPublicKeyIsInvalid() {
        byte[] nonce = java.util.Base64.getDecoder().decode("MDEyMzQ1Njc4OQ==");
        byte[] message = java.util.Base64.getDecoder().decode("dXpBb1FGcUxnUmVpZHc9PQ==");
        byte[] signature = java.util.Base64.getDecoder().decode("r00WeXEj+07DUZb3JY6fbbKhHtQcxtLZsJUVU6liFZQKCLQYu77EXFZx4Vaa5VBtKpPK6tDGovHGgrgyizOm70VUZgzzBb0emvRIGSWhAKkcLL1z1HYwApnUE6XFFb96LUF4XM//QhEM774dX4ciqQ==");
        byte[] invalidPublicKey = new byte[0];

        int type = 1;
        byte[] blindingFactor = new byte[0];
        ProofMessage[] proofMessage = new ProofMessage[]{
                new ProofMessage(type, message, blindingFactor),
        };

        byte[] bbsKey = Bbs.blsPublicToBbsPublicKey(invalidPublicKey, 1);

        try {
            Bbs.createProof(bbsKey, nonce, signature, proofMessage);
            fail("Expected an exception to be thrown");
        } catch (Exception exception) {
            assertEquals("Unable to set public key", exception.getMessage());
        }
    }

    @Test
    public void shouldThrowExceptionMessageWhenProofNonceIsInvalid() {
        byte[] invalidNonce = null;
        byte[] message = java.util.Base64.getDecoder().decode("dXpBb1FGcUxnUmVpZHc9PQ==");
        byte[] publicKey = java.util.Base64.getDecoder().decode("qJgttTOthlZHltz+c0PE07hx3worb/cy7QY5iwRegQ9BfwvGahdqCO9Q9xuOnF5nD/Tq6t8zm9z26EAFCiaEJnL5b50D1cHDgNxBUPEEae+4bUb3JRsHaxBdZWDOo3pb");
        byte[] signature = java.util.Base64.getDecoder().decode("r00WeXEj+07DUZb3JY6fbbKhHtQcxtLZsJUVU6liFZQKCLQYu77EXFZx4Vaa5VBtKpPK6tDGovHGgrgyizOm70VUZgzzBb0emvRIGSWhAKkcLL1z1HYwApnUE6XFFb96LUF4XM//QhEM774dX4ciqQ==");


        int type = 1;
        byte[] blindingFactor = new byte[0];
        ProofMessage[] proofMessage = new ProofMessage[]{
                new ProofMessage(type, message, blindingFactor),
        };

        byte[] bbsKey = Bbs.blsPublicToBbsPublicKey(publicKey, 1);

        try {
            Bbs.createProof(bbsKey, invalidNonce, signature, proofMessage);
            fail("Expected an exception to be thrown");
        } catch (Exception exception) {
            assertEquals("Unable to set nonce", exception.getMessage());
        }
    }


    @Test
    public void shouldThrowExceptionMessageWhenProofSignatureIsInvalid() {
        byte[] nonce = java.util.Base64.getDecoder().decode("MDEyMzQ1Njc4OQ==");
        byte[] message = java.util.Base64.getDecoder().decode("dXpBb1FGcUxnUmVpZHc9PQ==");
        byte[] publicKey = java.util.Base64.getDecoder().decode("qJgttTOthlZHltz+c0PE07hx3worb/cy7QY5iwRegQ9BfwvGahdqCO9Q9xuOnF5nD/Tq6t8zm9z26EAFCiaEJnL5b50D1cHDgNxBUPEEae+4bUb3JRsHaxBdZWDOo3pb");
        byte[] invalidSignature = java.util.Base64.getDecoder().decode("rpldJh9DkYe4FvX7WPYI+GNhBM7uB3UGg3NcJX+NTts9E5R9TtHSYszqVfLxdq0Mb45jyd82laouneFYjB5TreM5Qpo9TyO0yNPdaanmfW0wCeLp3r0bhdfOF67GGL01KHY56ojoaSWBmr2lpqRU2Q==");

        int type = 1;
        byte[] blindingFactor = new byte[0];
        ProofMessage[] proofMessage = new ProofMessage[]{
                new ProofMessage(type, message, blindingFactor),
        };

        byte[] bbsKey = Bbs.blsPublicToBbsPublicKey(publicKey, 1);

        try {
            Bbs.createProof(bbsKey, nonce, invalidSignature, proofMessage);
            fail("Expected an exception to be thrown");
        } catch (Exception exception) {
            assertEquals("Unable to create proof", exception.getMessage());
        }
    }

    @Test
    public void shouldThrowExceptionMessageWhenProofMessageIsInvalid() {
        byte[] nonce = java.util.Base64.getDecoder().decode("MDEyMzQ1Njc4OQ==");
        byte[] message = java.util.Base64.getDecoder().decode("dXpBb1FGcUxnUmVpZHc9PQ==");
        byte[] publicKey = java.util.Base64.getDecoder().decode("qJgttTOthlZHltz+c0PE07hx3worb/cy7QY5iwRegQ9BfwvGahdqCO9Q9xuOnF5nD/Tq6t8zm9z26EAFCiaEJnL5b50D1cHDgNxBUPEEae+4bUb3JRsHaxBdZWDOo3pb");
        byte[] signature = java.util.Base64.getDecoder().decode("r00WeXEj+07DUZb3JY6fbbKhHtQcxtLZsJUVU6liFZQKCLQYu77EXFZx4Vaa5VBtKpPK6tDGovHGgrgyizOm70VUZgzzBb0emvRIGSWhAKkcLL1z1HYwApnUE6XFFb96LUF4XM//QhEM774dX4ciqQ==");

        int type = 5;
        byte[] blindingFactor = new byte[0];
        ProofMessage[] proofMessage = new ProofMessage[]{
                new ProofMessage(type, message, blindingFactor),
        };

        byte[] bbsKey = Bbs.blsPublicToBbsPublicKey(publicKey, 1);

        try {
            Bbs.createProof(bbsKey, nonce, signature, proofMessage);
            fail("Expected an exception to be thrown");
        } catch (Exception exception) {
            assertEquals("Unable to add proof message", exception.getMessage());
        }
    }

//    @Test public void testBlsVerifyProofRevealingSingleMessageFromSingleMessageSignature() {
//        byte[] nonce = java.util.Base64.getDecoder().decode("MDEyMzQ1Njc4OQ==");
//        byte[] message = java.util.Base64.getDecoder().decode("dXpBb1FGcUxnUmVpZHc9PQ==");
//        byte[] publicKey = java.util.Base64.getDecoder().decode("qJgttTOthlZHltz+c0PE07hx3worb/cy7QY5iwRegQ9BfwvGahdqCO9Q9xuOnF5nD/Tq6t8zm9z26EAFCiaEJnL5b50D1cHDgNxBUPEEae+4bUb3JRsHaxBdZWDOo3pb");
//        byte[] signature = java.util.Base64.getDecoder().decode("r00WeXEj+07DUZb3JY6fbbKhHtQcxtLZsJUVU6liFZQKCLQYu77EXFZx4Vaa5VBtKpPK6tDGovHGgrgyizOm70VUZgzzBb0emvRIGSWhAKkcLL1z1HYwApnUE6XFFb96LUF4XM//QhEM774dX4ciqQ==");
//
//        int type = 1;
//        byte[] blindingFactor = new byte[0];
//        ProofMessage[] proofMessage = new ProofMessage[]{
//                new ProofMessage(type, message, blindingFactor),
//        };
//
//        byte[] proof = new byte[0];
//        byte[] bbsPublicKey = Bbs.blsPublicToBbsPublicKey(publicKey, 1);
//
//        try {
//            proof = Bbs.createProof(bbsPublicKey, nonce, signature, proofMessage);
//        } catch (Exception exception) {
//            exception.printStackTrace();
//        }
//
//        assertNotNull(proof);
//        System.out.println("PublicKey length: " + publicKey.length);
//        System.out.println("BBS PublicKey length: " + bbsPublicKey.length);
//        System.out.println("Signature length: " + signature.length);
//        System.out.println("Proof: " + java.util.Base64.getEncoder().encodeToString(proof) + " length: " + proof.length);
//
//        Map<Integer, byte[]> messages = new HashMap<Integer, byte[]>() {{
//            put(0, message);
//        }};
//
///*
//        Map<Integer, byte[]> messages = Map.of(0, "KNK0ITRAF+NrGg==".getBytes());
//        byte[] bbsPublicKey = java.util.Base64.getDecoder().decode("qJgttTOthlZHltz+c0PE07hx3worb/cy7QY5iwRegQ9BfwvGahdqCO9Q9xuOnF5nD/Tq6t8zm9z26EAFCiaEJnL5b50D1cHDgNxBUPEEae+4bUb3JRsHaxBdZWDOo3pboZyjM38YgjaUBcjftZi5gb58Qz13XeRJpiuUHH06I7/1Eb8oVtIW5SGMNfKaqKhBAAAAAYPPztgxfWWw01/0SSug1oLfVuI4XUqhgyZ3rS6eTkOLjnyR3ObXb0XCD2Mfcxiv6w==");
//        byte[] proof = java.util.Base64.getDecoder().decode("AAEBoyrn7FHZEDAfMBckBd9x4N1m5kpnjh/Oryw5XYkpqr7iqtSxYIqS7pmKAA/DjDt7lFkfu7oAYdKJlSD6WVGokHwtOW/EDkJXjrjQ4NVktiu0vfy0dEhy+CBhhcnwBQyfseuIeIuTZ1+2cAVaiOlzdc/K/yEKjSAQPqIOkmj9OaLLkfmljd5abf7dYMap0UugAAAAdKdyg+I6PbYt6HpcGCEX9KhVD0axbsNjch87YqUy3daNKsV5IQB3e3rKK5yR2sPpjgAAAAJvj/vM9cIsN/hZQEVpMwGVGAp39yWx0zsguRORUz2gXg8/IuO8e6l4L1ZZ7viCOgP9hYK9ZCeoMknyF4OhsuwpqF2pddX8+5FEuN2IDZTX+NFYmPnp/60HGLU4lmN2xS1XIWU5UzFAi6N6VQLyOQbKAAAAAlXEI+c6GIRznGyDVAj3UaukO+z2I3V/HsS9XQFrjwgPDphFi+XQwULUNGUzGins9XMU+m44a+SqiRu6tahdZFk=");
//        byte[] nonce = java.util.Base64.getDecoder().decode("v3bb/Mz+JajUdiM2URfZYcPuqxw=");
//*/
//
//        boolean isVerified = false;
//
//        try {
//            isVerified = Bbs.verifyProof(bbsPublicKey, proof, nonce, messages);
//        } catch (Exception exception) {
//            exception.printStackTrace();
//        }
//
//        assertTrue(isVerified);
//    }
}
